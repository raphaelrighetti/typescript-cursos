TypeScript é um superset do JavaScript, tendo tudo que o JavaScript tem, só que com features a mais e uma sintaxe tipada.

O nosso código TS precisa ser transpilado para um código JS convencional para o navegador entender, e para isso os nossos códigos são transpilados sempre para a pasta dist, que será a pasta do deploy, por assim dizer.

Além disso, o que realmente mais atrai no TypeScript é saber que o nosso código está com problema antes mesmo de rodá-lo, pois como há uma "compilação" a ser feita, o compilador do TypeScript irá nos avisar dos problemas enquanto ainda estamos codando.

============MÓDULOS============

Podemos, com o JS, adicionar um script do tipo "module" no nosso arquivo HTML, assim fazendo com que todos os outros módulos utilizados por esse script funcionem, o que é uma coisa muito boa e faz a gente não precisar ficar importando um monte de scripts no arquivo HTML.

Podemos pensar nesse módulo inicial como uma classe "main" do Java, que é onde a aplicação sempre vai iniciar.

Para inseri-lo no nosso arquivo HTML, basta incluí-lo em uma tag <script></script> com o type="module".

============MODELO============

Um modelo é uma representação de algo real no nosso código, por exemplo uma negociação.

============COMPILADOR============

Assim que trocamos a extensão de um arquivo .js para .ts, temos um linting muito mais específico nos erros, mostrando várias coisas que podem causar problemas enquanto estamos codando.

Os nossos arquivo .ts não podem ficar na pasta "dist", pois a pasta dist é o nosso código final, compilado para js a partir dos arquivos ts, e se tivermos arquivos ts lá, o navegador não conseguirá lê-los. Devemos colocar os arquivos .ts na pasta "app".

Instalamos o compilador por meio do npm, mas só instalá-lo não basta, temos que ter um arquivo "tsconfig.json" que irá dizer ao compilador como ele deve se comportar.

Podemos usar a opção: 

"compilerOptions": {
    "outDir': <diretório de saída dos arquivos compilados>,
    "target": <versão do js>,
    "noEmitOnError": true
},
"include": [<caminhos de pastas com os arquivos .js>]

Desta forma estamos falando para o compilador do TypeScript que ele deve compilar os arquivos para certa pasta, usando tal versão do JavaScript e onde estão os arquivos .ts que ele deve compilar. Também dizemos que ele não deve compilar os arquivos se estiverem com erro de  compilação.

Essa é a configuração mínima que precisamos fazer no nosso compilador do TypeScript para ele funcionar.

============COMPILANDO============

Para compilarmos o nosso código, podemos criar um script no arquivo package.json, que ficaria assim:

"compile": "tsc"

Assim toda vez que rodarmos o script "compile", iremos rodar o comando tsc para compilar os nossos arquivos.

Também podemos rodar o compilador de modo que a cada mudança nos arquivos .ts ele compile automaticamente. Para isso, basta criamos um script:

"watch": "tsc -w"

Dessa forma os arquivos serão gerados automaticamente na pasta de saída, mas não teremos o servidor rodando para escutar a essas alterações. Para fazer isso precisamos usar o módulo "concurrently", fazendo um script que roda outros scripts ao mesmo tempo. Por exemplo:

"start": "concurrently \"npm run watch\" \"npm run server\""

O compilador respeita a árvore de pastas que temos no diretório onde estão os nossos arquivos .ts, criando a mesma árvore na pasta de saída, mesmo que não tenhamos criado nem a pasta de saída em si.

============SINTAXE TIPADA============

Podemos usar o modificador de visibilidade "private" em atributos de classes no TypeScript, assim não permitindo acesso à eles. Também podemos usar o "public".

Para getters, utilizamos os métodos get padrão que temos no JS também.

Para especificarmos o tipo em instâncias, basta utilizarmos a sintaxe:

<instância>: <tipo>

Sim, o tipo vem na frente da declaração.

O TypeScript possui vários tipos nativos dele que representam uma série de coisas, inclusive vários tipos de elementos HTML, como o "HTMLInputElement", por exemplo.

Importante lembrar que em vários casos o TS adiciona o tipo certo à instância sem especificarmos ele, com base no tipo que estamos atribuindo a ela.

Por padrão, quando não especificamos nenhum tipo em alguma instância no nosso código, o TypeScript atribui o tipo "any", o que significa que aquela instância poderá qualquer tipo, o que não é o ideal.

Para tirarmos esse comportamento, podemos adicionar a seguinte configuração no nosso "tsconfig.json":

"noImplicitAny": true

É uma boa prática sempre especificar o tipo em atributos de classes, parâmetros recebidos em métodos e retornos de métodos e funções, só deixando o TS atribuir automaticamente quando estamos criando variáveis dentro de métodos.

============CONTROLLER============

Um controller no TS nada mais é do que uma classe ou módulo que vai ser responsável por tratar a interação do usuário na página e fazer a o que deve se feito a partir desta interação.

Normalmente vamos ter esses controllers atrelados a elementos do nosso dom, como um botão, por exemplo, assim chamando o controller quando algum evento ocorrer neste elemento.

============GENERICS============

No TypeScript temos Generics, assim como no Java, e a sintaxe é bem parecida. Exemplo:

"private lista: Array<string> = [];"

Desta forma dizemos que a nossa variável "lista" é um Array de strings, assim não permitindo adicionarmos nenhum outro tipo como item do Array. Inclusive, quando fazemos um for nos itens do Array, temos todo o auto-complete com os métodos e propriedades de String.

Se temos um Array<any> encapsulado em uma classe que não queremos que seja modificável fora dos métodos da classe, podemos retornar uma cópia do Array<any> em vez dele em si no nosso método get. Para fazer isto, basta usar o spread:

"return [...<nosso Array<any>>];"

Essa é uma forma de resolver este problema relativamente antiga e do próprio JS, o TypeScript possui uma forma bem mais eficiente de fazer isso que é usar o modificador "readonly". Para isso, basta modificar o retorno do nosso método para "ReadonlyArray<<tipo>>". Exemplo:

listar(): ReadonlyArray<any> {
    return <nossa lista privada>;
}

Desta forma o compilador do TS não nos deixará executar nenhum método que modifique a lista, gerando um erro de compilação quando tentamos fazer algo do tipo.

============PARTICULARIDADES============

No TypeScript podemos declarar os atributos da nossa classe nos próprios argumentos do construtor, ou seja, não precisamos nem ter um corpo no construtor e nem tê-los na classe em si. Para isso basta utilizar a sintaxe:

constructor(
    private _meuAtributo: any
) {}

Desta forma teremos um atributo privade chamado _meuAtributo na nossa classe. Funciona com "public" também.

Quando estamos criando algum atributo, parâmetro ou variável que é um Array, não precisamos necessariamente utilizar a sintaxe com Generics, podemos utilizar da seguinte forma:

"private _pessoas: Pessoa[] = [];"

Isso dá no mesmo.

Podemos utilizar essa sintaxe para ReadonlyArray também, basta usar o modificador "readonly":

get pessoas(): readonly Pessoa[] {
    return this._pessoas;
}

Também podemos usar o modificador "readonly" para atributos públicos da nossa classe, assim fazendo com que não precisemos dos getters, mas ainda assim impossibilitando a atribuição de valores fora da classe.

Importante lembrar que, nesse caso, ainda conseguimos acessar todos os métodos do atributos, inclusive os que o modificam. Então o uso do readonly nesses casos pode não ser omais recomendável.

Importante lembrarmos que mesmo recebendo os atributos em métodos getters, ainda podemos utilizar os métodos que modificam esses atributos, então ainda continuamos com o mesmo problema.

O ideal para fazermos nesses casos é retornar uma nova instância idêntica à nossa propriedade, assim fazendo com que as modificações feitas não alterem o atributo real da classe.

============VIEW============

Views são as nossas classes ou módulos responsáveis por gerar a view do usuário, que no caso do front-end é algum componente da página ou uma página em si.

Podemos usar um template HTML na nossa classe view para inserir os dados dinamicamente nela, assim fazendo algo parecido com o JSX do React.

Lembrando que, como estamos usando o TS puro, para fazer essas coisas podemos usar os métodos do document que estão disponíveis para nós.

============Intl============

*Internationalization*

É um tipo com alguns métodos estáticos que nos permitem fazer coisas com funcionalidades do navegador, como formatar uma data com base na localidade do usuário, por exemplo.

============HERANÇA============

Herança no TypeScript funciona de forma bem similar à herança no Java, podendo, inclusive, usarmos o modificador preotected para que as filhas tenham acesso ao atributo da mãe.

Podemos usar Generics em classes criadas por nós mesmos, assim podendo deixar dinâmico o tipo do parâmetro recebido por algum método e etc.

Para isso, basta na declaração da classe usar a sintaxe:

"export class Algo<T> {}"

Com isso, basta colocar "T" como tipo das coisas que precisam usar esse Generics.

Podemos ter classes abstratas assim como no Java, podendo definir métodos abstratos e não abstratos nelas.

============VISIBILIDADE============

Quando omitimos o modificador de visibilidade, o TypeScript coloca public como padrão.

Podemos mudar a visibilidade de um método abstrato herdado da classe mãe na classe filha para deixá-lo mais visível, mas não o contrário. Se precisarmos proteger este método, devemos deixá-lo como protected na classe filha também.

Podemos ter métodos privados em classes normalmente.

============ENUM============

Enums no TypeScript são quase a mesma coisa que no Java.

Para declará-los, usamos a palavra chave "enum" em vez de "class" e definimos as constantes apenas declarando os nomes delas, com o TypeScript incrementando os valores inteiros delas automaticamente, sempre começando no 0.

É recomendável nós mesmos definirmos os valores dos enums, assim garantindo que eles vão estar certos, independente da ordem. Para fazer isso, basta atribuirmos valores com o sinal "=" na definição das constantes.

Enums não precisam ser apenas inteiros, podem ser qualquer valor que colocarmos para as constantes.
